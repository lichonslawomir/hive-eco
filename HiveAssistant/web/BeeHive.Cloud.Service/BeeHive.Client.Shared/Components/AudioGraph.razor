@using BeeHive.Contract.Aggregate.Models
@using BeeHive.Contract.Data.Models

<div class="graphs-container" style="display: flex; gap: 2rem; flex-wrap: wrap;justify-content: center;">
    @foreach (var hive in _hives)
    {
        <VisibilitySwitch 
            Hive="hive"
            Visible="@(!_hiddenHives.Contains(hive.Id))"
            VisibleChanged="() => ToggleDatasetVisibility(hive.Id)" />
    }
</div>
<div class="graphs-container" style="display: flex; gap: 2rem; flex-wrap: wrap;">
    <div style="flex: 1; min-width: 400px;">
        <h4>Frequence</h4>
        <Chart Config="frequenceLineChartConfig" @ref="_chartFrequence"></Chart>
    </div>
    <div style="flex: 1; min-width: 400px;">
        <h4>Amplitude</h4>
        <Chart Config="amplitudeLineChartConfig" @ref="_chartAmplitude"></Chart>
    </div>
</div>


@code {
    [Parameter] public required IList<HiveDto> Hives { get => _hives; set { _agregateDataChange = true; _hives = value; } }

    [Parameter]
    public required IList<TimeAggregateSeriesHivesDataModel> FrequenceAggregateData
    {
        get => _frequenceAggregateData;
        set
        {
            _agregateDataChange = _frequenceAggregateData != value;
            _frequenceAggregateData = value;
        }
    }
    [Parameter]
    public required IList<TimeAggregateSeriesHivesDataModel> AmplitudeAggregateData
    {
        get => _amplitudeAggregateData;
        set
        {
            _agregateDataChange = _amplitudeAggregateData != value;
            _amplitudeAggregateData = value;
        }
    }

    private IList<HiveDto> _hives = new List<HiveDto>();
    private IList<int> _hiddenHives = new List<int>();

    private IList<TimeAggregateSeriesHivesDataModel> _frequenceAggregateData = new List<TimeAggregateSeriesHivesDataModel>();
    private IList<TimeAggregateSeriesHivesDataModel> _amplitudeAggregateData = new List<TimeAggregateSeriesHivesDataModel>();

    private bool _agregateDataChange = true;

    private Chart _chartFrequence = null!;
    private Chart _chartAmplitude = null!;
    LineConfig frequenceLineChartConfig = new LineConfig();
    LineConfig amplitudeLineChartConfig = new LineConfig();

    protected override Task OnParametersSetAsync()
    {
        if (_agregateDataChange)
        {
            LoadGraphs();
            _agregateDataChange = false;
        }
        return Task.CompletedTask;
    }
    protected void LoadGraphs()
    {
        frequenceLineChartConfig.Data.Labels.Clear();
        frequenceLineChartConfig.Data.Datasets.Clear();
        var tt = FrequenceAggregateData;
        if (tt?.Any() == true)
        {
            var labels = tt.Select(dp => dp.Timestamp.ToLocalTime().ToString("yyyy-MM-dd HH:mm")).ToArray();
            ((List<string>)frequenceLineChartConfig.Data.Labels).AddRange(labels);
            for (int i = 0; i < _hives.Count; ++i)
            {
                if (_hiddenHives.Contains(_hives[i].Id))
                    continue;

                frequenceLineChartConfig.Data.Datasets.Add(new ChartJs.Blazor.LineChart.LineDataset<float>(tt.Select(dp => dp.MaxValue[i] ?? float.NaN).ToList())
                {
                    Label = $"Max. {_hives[i].Name}",
                    Fill = ChartJs.Blazor.Common.Enums.FillingMode.Absolute(i * 3 + 1),
                    BorderColor = _hives[i].GraphColor.ToRgbaShadow()
                });
                frequenceLineChartConfig.Data.Datasets.Add(new ChartJs.Blazor.LineChart.LineDataset<float>(tt.Select(dp => dp.MinValue[i] ?? float.NaN).ToList())
                {
                    Label = $"Min. {_hives[i].Name}",
                    Fill = ChartJs.Blazor.Common.Enums.FillingMode.Absolute(i * 3),
                    BorderColor = _hives[i].GraphColor.ToRgbaShadow()
                });
                frequenceLineChartConfig.Data.Datasets.Add(new ChartJs.Blazor.LineChart.LineDataset<float>(tt.Select(dp => dp.AvgValue[i] ?? float.NaN).ToList())
                {
                    Label = $"Avg. {_hives[i].Name}",
                    Fill = false,
                    BorderColor = _hives[i].GraphColor.ToHexColor()
                });
            }
        }

        amplitudeLineChartConfig.Data.Labels.Clear();
        amplitudeLineChartConfig.Data.Datasets.Clear();
        var hh = AmplitudeAggregateData;
        if (hh?.Any() == true)
        {
            var labels = hh.Select(dp => dp.Timestamp.ToLocalTime().ToString("yyyy-MM-dd HH:mm")).ToArray();
            ((List<string>)amplitudeLineChartConfig.Data.Labels).AddRange(labels);
            for (int i = 0; i < _hives.Count; ++i)
            {
                if (_hiddenHives.Contains(_hives[i].Id))
                    continue;

                amplitudeLineChartConfig.Data.Datasets.Add(new ChartJs.Blazor.LineChart.LineDataset<float>(hh.Select(dp => dp.MaxValue[i] ?? float.NaN).ToList())
                {
                    Label = $"Max. {_hives[i].Name}",
                    Fill = ChartJs.Blazor.Common.Enums.FillingMode.Absolute(i * 3 + 1),
                    BorderColor = _hives[i].GraphColor.ToRgbaShadow()
                });
                amplitudeLineChartConfig.Data.Datasets.Add(new ChartJs.Blazor.LineChart.LineDataset<float>(hh.Select(dp => dp.MinValue[i] ?? float.NaN).ToList())
                {
                    Label = $"Min. {Hives[i].Name}",
                    Fill = ChartJs.Blazor.Common.Enums.FillingMode.Absolute(i * 3),
                    BorderColor = _hives[i].GraphColor.ToRgbaShadow()
                });
                amplitudeLineChartConfig.Data.Datasets.Add(new ChartJs.Blazor.LineChart.LineDataset<float>(hh.Select(dp => dp.AvgValue[i] ?? float.NaN).ToList())
                {
                    Label = $"Avg. {Hives[i].Name}",
                    Fill = false,
                    BorderColor = _hives[i].GraphColor.ToHexColor()
                });
            }
        }
    }
}
